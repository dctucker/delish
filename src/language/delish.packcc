%prefix "deli"

%auxil "struct deli_t *"

%header {
	#include "stdarg.h"
	#include "kind.h"
	struct deli_t {
		const char *input;
		size_t offset;
		size_t length;
		void *parser;
	};
	
	#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
		if( !( dk##rule == dkComment || dk##rule == dkVLine || dk##rule >= dkA ) ) \
			deli_event(auxil->parser, event, dk##rule, level, pos, buffer, length)
	#define PCC_GETCHAR(auxil) deli_get_character( auxil )
	#define PCC_BUFFERSIZE 1024
	#define PCC_ERROR(auxil) pccError(auxil->parser, ctx->cur); return 0;

	#define VARNAME_ACTION_OUT      pcc_action_out
	#define VARNAME_PROGPRED_OUT    pcc_progpred_out
	#define VARNAME_CAPTURE_PREFIX  pcc_capture__

	#define BB(C,I)     bracket( auxil->parser, pcc_capture__0s, C, I )
	#define NS(K)       VARNAME_ACTION_OUT = nodeString( auxil->parser, dk##K   , pcc_capture__1s, pcc_capture__1e, pcc_capture__1)
	#define CN(N, K, ...) VARNAME_ACTION_OUT = createNode##N( auxil->parser, dk##K, __VA_ARGS__ )
	#define CN0(K) VARNAME_ACTION_OUT = createNode0( auxil->parser, dk##K )
	#define CN1(K, ...) CN(1, K, __VA_ARGS__ )
	#define CN2(K, ...) CN(2, K, __VA_ARGS__ )
	#define CN3(K, ...) CN(3, K, __VA_ARGS__ )
	#define NA(P,S)     nodeAppend( auxil->parser, P, S )
	#define SL(X)       setLine( auxil->parser, X, pcc_capture__0s )
	#define SLE(X)      setLine( auxil->parser, X, pcc_capture__0e )
	#define SL1(X)      setLine( auxil->parser, X, pcc_capture__1s )
	#define SL2(X)      setLine( auxil->parser, X, pcc_capture__2s )
	#define SL3(X)      setLine( auxil->parser, X, pcc_capture__3s )
	#define ER(MSG)     parserError( auxil->parser, pcc_capture__0s, MSG );
	// fprintf(stderr, "Parsing error: %s\n", MSG)

	#define GET_DK( _1, _2, _3, _4, NAME, ...) NAME
	#define DK(...) GET_DK( __VA_ARGS__, CN3, CN2, CN1, CN0)(__VA_ARGS__)

	void pccError(void*, size_t);
	int nodeAppend(void*, int, int);
	int createNode0(void*, int);
	int createNode1(void*, int, int);
	int createNode2(void*, int, int, int);
	int createNode3(void*, int, int, int, int);
	int nodeString(void*, int, size_t, size_t, char*);
	int bracket(void*, int, char, char);
	int parserError(void*, size_t, char*);
	int setLine(void*, int, int);
	void deli_event(void*, int, int, int, size_t, char*, size_t);

	const char
		*expected_condition  = "expected condition",
		*expected_expression = "expected expression",
		*invalid_expression  = "invalid expression",
		*expected_body       = "expected body",
		*expected_variable   = "expected variable",
		*expected_invocation = "expected invocation",
		*expected_streamable = "expected streamable expression";
}

%source {
	int deli_get_character( struct deli_t *auxil )
	{
		if( auxil->offset >= auxil->length )
			return -1;
		return (auxil)->input[ auxil->offset++ ];
	}
}

Script        <- c:Code                                              { DK( Script, c ); }

Code          <-                                                     { DK( Code ); }
              (  S* l:VLine                                          { if( l >= 0 ) NA( $$, l ); }
              )+ S*

Body          <- ( CLeft _ < c:Code > _ CRight                      ~{ ER("missing `}`"); }
                 )                                                  ~{ ER( expected_body ); }
                                                                     { $$ = c; SL1(c); }

VLine         <-
              (                             ( "\n" / ";" )           { $$ = -1; }
              /  Comment                                             { $$ = -1; }
              /  a:Block                    ( "\n" / ";" )           { $$ = a; }
              /  a:Block     S* Comment*                             { $$ = a; }
              /  a:Statement S*             ( "\n" / ";" )           { $$ = a; }
              /  a:Statement S* Comment*                             { $$ = a; }
              /  e:Expr                     ( "\n" / ";" )           { $$ = e; }
              )                                                      { if( $$ >= 0 ) SL($$); }

Comment       <- '#' (! "\n" .)* "\n"
Block         <-
              (  !VarOp
               ( &If    a:Conditional
               / &Do    a:DoLoop
               / &While a:WhileLoop
               / &For   a:ForLoop
               / a:FunctionDef
               )
              /  a:Subshell
              )                                                      { DK( Block    , a ); SL(a); }

Statement     <-
              (  a:VariableStmt / a:VarDerefStmt
              /  a:LocalStmt    / a:ArgStmt
              /  a:EnvStmt      / a:IncludeStmt / a:StreamStmt
              /  a:CloseStmt    / a:RunStmt
              /  a:FunctionStmt / a:BreakStmt
              /  a:ContinueStmt / a:ReturnStmt  / a:Push / a:Pop )   { DK( Statement  , a ); SL($$); }

Conditional   <- If          S+ < e:Condition >                     ~{ ER( expected_condition ); }
                             S+   c:Body                             { DK( Conditional, e, c ); SL1(e); }
              (  S+ Elif     S+ < e:Condition >                     ~{ ER( expected_condition ); }
                             S+   c:Body                             { NA( $$, e ); NA( $$, c ); SL2(e); }
              )* (           S+ < e:Else      >                      { NA( $$, e ); SL3(e); }
                             S+   c:Body                             { NA( $$, c ); }
              )? _

WhileLoop     <- While       S+ e:Condition                         ~{ ER( expected_condition ); }
                             S+ c:Body _                             { DK( WhileLoop  , e, c ); }

DoLoop        <- Do          S+ c:Body                              ~{ ER( expected_body ); }
                 _ While     S+ e:Condition                         ~{ ER( expected_condition ); }
                                                                     { DK( DoLoop     , c, e ); }

ForLoop       <- For         S+ v:Variable                          ~{ ER( expected_variable ); }
                             S+ In                                  ~{ ER("expected `in`"); }
                             S+ e:Iterable                          ~{ ER("expected iterable"); }
                             S+ c:Body                              ~{ ER( expected_body ); }
                             _                                       { DK( ForLoop    , v, e, c ); }

FunctionDef   <- !Keyword i:Identifier S* AssignOp
                                       S* c:Body                    ~{ ER( expected_body ); }
                                       _                             { DK( FunctionDef, i, c ); }

Subshell      <- Sub   S+ c:Body                                    ~{ ER( expected_body ); }
                       _                                             { DK( Subshell   , c ); }

BreakStmt     <- Break                                               { DK( BreakStmt ); }
ContinueStmt  <- Continue                                            { DK( ContinueStmt ); }

ReturnStmt    <- Return                                              { DK( ReturnStmt ); }
              (  S+ e:Expr                                          ~{ ER( invalid_expression ); }
                                                                     { NA( $$, e ); }
              )?

VariableStmt  <- &VarOp v:Variable                                  ~{ ER("invalid variable name"); }
              (      S* o:AssignOp S* e:AssignExpr S*               ~{ ER( invalid_expression ); }
              /      S* o:AppendOp S* e:AppendExpr S*               ~{ ER( invalid_expression ); }
              /      S* o:RemoveOp S* e:AppendExpr S*               ~{ ER( invalid_expression ); }
              )                                                      { DK( VariableStmt, v, o, e ); }

VarDerefStmt  <- &VarOp v:VarDeref S* o:AssignOp S* e:AssignExpr S*  { DK( VarDerefStmt, v, o, e ); }

AssignExpr    <-
              (  e:OpenExpr / e:ArgExpr /  e:RunStmt
              /  e:FunctionCall / e:Cast / e:Expr
              )                                                      { $$ = e; }

AppendExpr    <-
              (   e:ArgExpr / e:Arg / e:FunctionCall / e:VarDeref
              /   e:ConstExpr       / e:Cast
              )                                                      { $$ = e; }

OpenExpr      <- Open  (S+ o:RedirOper)?
                        S+ ( p:Path / p:FunctionCall / p:VarDeref ) ~{ ER("expected path"); }
                                                                     { DK( OpenExpr, p, o); }
CloseStmt     <-
              (  Close   S+ v:Variable                              ~{ ER( expected_variable ); }
              /  v:Variable DerefOp Close
              )                                                      { DK( CloseStmt, v ); }

LocalStmt     <- Local   S+ v:Variable                              ~{ ER( expected_variable ); }
                                                                     { DK( LocalStmt, v ); }
              (  S* o:AssignOp S* e:AssignExpr                      ~{ ER("expected assignable expression"); }
                                                                     { NA( $$, o ); NA( $$, e ); }
              )?

ArgStmt       <- ArgKw
              (  a:ArgNames S* o:DefaultOp S* d:ArgDefault           { DK( ArgStmt, a, o, d); }
              /  a:ArgNames                                          { DK( ArgStmt, a); }
              /  S+ v:Variable                                       { DK( ArgStmt, v); }
              )                                                     ~{ ER("argument must be flags or a variable") }

EnvStmt       <- Env   S+ v:Variable                                ~{ ER( expected_variable ); }
                                                                     { DK( EnvStmt, v ); }
              (  S* o:DefaultOp S* e:EnvDefault                     ~{ ER("expected constant expression"); }
                                                                     { NA( $$, o ); NA( $$, e ); }
              /  S* o:AssignOp  S* e:Expr                           ~{ ER( expected_expression ); }
                                                                     { NA( $$, o ); NA( $$, e ); }
              )?

IncludeStmt   <- Include   S+ s:StrLiteral                          ~{ ER("expected string literal"); }
                                                                     { DK( IncludeStmt, s ); }

StreamStmt    <-
              (  v:Variable DerefOp s:Stream S+ l:ExprList          ~{ ER( expected_streamable ); }
                                                                     { DK( StreamStmt,  v, s, l ); }
              /                     s:Stream S+ l:ExprList          ~{ ER( expected_streamable ); }
                                                                     { DK( StreamStmt,  s, l ); }
              )

RunStmt       <-
              (  f:RunFlags  S+  Run                                 { DK( RunStmt, f ); }
              /                  Run                                 { DK( RunStmt ); }
              )              S+  i:Invocation                       ~{ ER( expected_invocation ); }
                                                                     { NA( $$, i ); }
              (  S* PipeOp S* i:Invocation                          ~{ ER( expected_invocation ); }
                                                                     { NA( $$, i ); }
              )*

RunFlags      <-
              (  f:AsyncFlag                                         { DK( RunFlags, f ); }
              /  f:RedirFlag                                         { DK( RunFlags, f ); }
              /  (f1:AsyncFlag f2:RedirFlag)                         { DK( RunFlags, f1, f2 ); }
              )

FunctionStmt  <- !Keyword c:FunctionCall                             { DK( FunctionStmt, c ); SL(c); }
FunctionCall  <- !Keyword c:Callable                                 { $$ = c; }
              (                          S+ e:Expr                   { NA( $$, e ); }
              )*

Callable      <- !Type i:Identifier                                  { DK( FunctionCall, DK( Callable, i ) ); }
                          ( DerefOp ( i:Identifier / i:Integer )     { DK( FunctionCall, DK( Callable, $$, i ) ); }
                                                                 )*
              /  !Type v:Variable                                    { DK( VarDeref, v ); }
                          ( DerefOp ( i:Identifier / i:Integer )     { DK( FunctionCall, DK( Callable, $$, i ) ); }
                                                                 )+
              /        t:Type                                        { DK( Type, t ); }
                          ( DerefOp ( i:Identifier / i:Integer )     { DK( FunctionCall, DK( Callable, $$, i ) ); }
                                                                 )+

ArgDefault    <- e:ConstExpr                                         { DK( ArgDefault, e ); }
EnvDefault    <- e:ConstExpr                                         { DK( EnvDefault, e ); }

ExprList      <-             e:Expr                                  { DK( ExprList, e ); }
              (  S* SepOp S* e:Expr                                 ~{ ER( expected_expression ); }
                 S*                                                  { NA( $$, e ); }
              )*

Invocation    <- c:Command                                           { DK( Invocation, c ); }
              (  S+ !PipeOp (e:Expr / e:String)                      { NA( $$, e ); }
              )*

ArgExpr       <- a:Arg (S+ / AssignOp) e:Expr?                       { DK( ArgExpr, a, e ); }

ConstExpr     <-
              (  e:Number / e:StrBlock / e:StrLiteral
              /  e:Boolean / e:Array / e:Object
              /  e:Path / e:JsonBlock
              )                                                      { $$ = e; }

Expr          <-
              (  s:MathExpr
              /  s:Array    / s:Object
              /  s:Arg
              /  s:StrBlock / s:StrLiteral / s:Regex
              /  s:DateTime / s:Number     / s:Boolean
              /  s:BoolExpr / s:Error      / s:Signal
              /  s:Path     / s:JsonBlock
              /  s:Cast     / s:FunctionCall / s:VarDeref
              )                                                      { DK( Expr, s); }

Iterable      <- ( s:Array / s:FunctionCall / s:VarDeref )           { DK( Iterable, s ); }

Condition     <- a:OrExpr                                            { DK( Condition, a); SL($$); }
OrExpr        <- l:OrExpr  S+ ( o:BoolOr / o:BoolNor  ) S+ r:AndExpr { DK( CondExpr, o, l, r); }
               /                                           r:AndExpr { $$ = r; }
AndExpr       <- l:AndExpr S+ (o:BoolAnd / o:BoolNand ) S+ r:NotExpr { DK( CondExpr, o, l, r); }
               /                                           r:NotExpr { $$ = r; }
NotExpr       <- o:BoolNot S+ r:CondExpr                             { $$ = o; NA($$, r); }
               /              r:CondExpr                             { $$ = r; }
CondExpr      <-
              (  s:Arg
              /  s:BoolExpr
              /  s:FunctionCall
              /  s:VarDeref / s:Boolean
              )                                                      { $$ = s; }

BitNand       <- Nand                                                { DK( BitNand ); }
BitNor        <- Nor                                                 { DK( BitNor  ); }
BitAnd        <- And                                                 { DK( BitAnd  ); }
BitOr         <- Or                                                  { DK( BitOr   ); }
BitXor        <- Xor                                                 { DK( BitXor  ); }
BitXnor       <- Xnor                                                { DK( BitXnor ); }
BitShl        <- Shl                                                 { DK( BitShl  ); }
BitShr        <- Shr                                                 { DK( BitShr  ); }
BitNot        <- Not                                                 { DK( BitNot  ); }

MathExpr      <- PLeft S* a:BOrExpr S* PRight                        { $$ = a; }

BOrExpr       <- l:BOrExpr  S+ ( o:BitOr / o:BitNor )
                            S+                         r:BXorExpr    { DK( MathExpr, o, l, r ); }
              /                                        r:BXorExpr    { $$ = r; }

BXorExpr      <- l:BXorExpr S+ ( o:BitXor / o:BitXnor )
                            S+                         r:BAndExpr    { DK( MathExpr, o, l, r ); }
              /                                        r:BAndExpr    { $$ = r; }

BAndExpr      <- l:BAndExpr S+ ( o:BitAnd / o:BitNand )
                            S+                         r:BShExpr     { DK( MathExpr, o, l, r ); }
              /                                        r:BShExpr     { $$ = r; }

BShExpr       <- l:BShExpr S+ ( o:BitShl / o:BitShr )
                           S+                          r:AddExpr     { DK( MathExpr, o, l, r ); }
              /                                        r:AddExpr     { $$ = r; }

AddExpr       <- l:AddExpr S+ ( o:AddOp / o:SubOp )
                           S+                          r:MulExpr     { DK( MathExpr, o, l, r ); }
               /                                       r:MulExpr     { $$ = r; }

MulExpr       <- l:MulExpr S+ ( o:MulOp / o:DivOp / o:ModOp )
                           S+                          r:BNotExpr    { DK( MathExpr, o, l, r ); }
               /                                       r:BNotExpr    { $$ = r; }

BNotExpr      <-                o:BitNot
                           S+                          r:PrimExpr    { $$ = o; NA($$, r); }
               /                                       r:PrimExpr    { $$ = r; }

PrimExpr      <- e:Expr                                              { $$ = e; }

BoolExpr      <-
              (      n:BoolNot S+ c:Comparison                       { DK( BoolExpr, n ); NA(n, c); }
               /                  c:Comparison                       { DK( BoolExpr, c ); }
              )(  S+ o:BoolOp2 S+ b:BoolExpr                         { DK( BoolExpr, o, $$, c); }
              )*

BoolOp2       <- o:BoolOr / o:BoolNor / o:BoolAnd / o:BoolNand       { DK( BoolOp2, o ); }
BoolNot       <- Not                                                 { DK( BoolNot ); }
BoolOr        <- Or                                                  { DK( BoolOr ); }
BoolAnd       <- And                                                 { DK( BoolAnd ); }
BoolNor       <- Nor                                                 { DK( BoolNor ); }
BoolNand      <- Nand                                                { DK( BoolNand ); }

Comparison    <- e1:CompExpr S+ o:CompOper S+ e2:CompExpr           ~{ ER("expected comparable expression"); }
                                                                     { DK( Comparison, o, e1, e2 ); }
CompExpr      <-
              (  s:FunctionCall / s:VarDeref
              /  s:StrBlock / s:StrLiteral / s:Regex
              /  s:MathExpr
              /  s:Number / s:Boolean / s:Path / s:Arg
              )                                                      { $$ = s; }
CompOper      <-
              (  o:GeOp / o:GtOp / o:LeOp / o:LtOp
              /  o:EqOp / o:NeOp / o:MatchOp
              )                                                      { $$ = o; }

VarDeref      <-
              (  &VarOp n:Variable                                   { DK( VarDeref, n ); }
              )
              (  DerefOp
               ( s:StrLiteral / s:Integer
               / s:Variable   / s:Identifier  )                     ~{ ER("expected literal, variable or identifier"); }
                                                                     { NA( $$, s ); }
              )*

RedirFlag     <- Redir                                               { DK( RedirFlag ); }
              (  S+
               ( i:VarDeref / i:Path / i:Stream )                   ~{ ER("expected source"); }
                 S* r:RedirOper S*                                  ~{ ER("expected operator"); }
               ( o:VarDeref / o:Path / o:Stream )                   ~{ ER("expected destination"); }
                                                                     { NA( r, i ); NA( r, o ); NA( $$, r ); }
              )+

AsyncFlag     <- Async                                               { DK( AsyncFlag ); }

Cast          <- t:Type S* PLeft S* e:Expr                          ~{ ER( expected_expression ); }
                                 S*        PRight                    { DK( Cast, t, e ); }

Json          <- "json"
Sub           <- "sub"
If            <- "if"
Elif          <- "elif"
Else          <- "else"                                              { DK( Else ); }
Do            <- "do"
While         <- "while"
For           <- "for"
In            <- "in"
Out           <- "out"
Err           <- "err"
Include       <- "include"
True          <- "true"
False         <- "false"
Env           <- "env"
ArgKw         <- "arg"
Local         <- "local"
Return        <- "return"
Break         <- "break"
Continue      <- "continue"
Async         <- "async"
Redir         <- "redir"
Shl           <- "shl"
Shr           <- "shr"
And           <- "and"
Or            <- "or"
Nand          <- "nand"
Nor           <- "nor"
Xor           <- "xor"
Xnor          <- "xnor"
Not           <- "not"
Push          <- "push"                                              { DK( Push ); }
Pop           <- "pop"                                               { DK( Pop ); }
Open          <- "open"
Close         <- "close"
Run           <- "run"

Keyword       <-
              (  Json   / Sub   / If       / Elif    / Else
              /  Do     / While / For
              /  In     / Out   / Err      / Include
              /  True   / False / Env      / ArgKw   / Local
              /  Return / Break / Continue
              /  Async  / Redir / And      / Or      / Not
              /  Push   / Pop   / Open     / Close   / Run
              )

Type          <- "Integer"                                           { DK( Integer    ); }
              /  "Decimal"                                           { DK( Decimal    ); }
              /  "DateTime"                                          { DK( DateTime   ); }
              /  "Arg"                                               { DK( Arg        ); }
              /  "Array"                                             { DK( Array      ); }
              /  "Boolean"                                           { DK( Boolean    ); }
              /  "Identifier"                                        { DK( Identifier ); }
              /  "Error"                                             { DK( Error      ); }
              /  "Signal"                                            { DK( Signal     ); }
              /  "Path"                                              { DK( Path       ); }
              /  "Object"                                            { DK( Object     ); }
              /  "Regex"                                             { DK( Regex      ); }
              /  "Stream"                                            { DK( Stream     ); }
              /  "String"                                            { DK( String     ); }
              /  "Variable"                                          { DK( Variable   ); }

ArgNames      <- S+ a:Arg                                            { DK( ArgNames, a); }
              (  S+ a:Arg                                            { NA( $$, a); }
              )*

Arg           <- &'-'
              (  l:ArgLong                                           { DK( Arg, l ); }
              /  s:ArgShort                                          { DK( Arg, s ); }
              )                                                     ~{ ER("invalid argument name"); }

Array         <- ALeft S* ARight                                     { DK( Array ); }
              /  ALeft                                               { DK( Array ); }
              (      _  e:Expr                                       { NA( $$, e ); }
                     S*       SepOp? _
              )* ARight

Object        <- ALeft                                               { DK( Object ); }
              (         _  p:Pair                                    { NA( $$, p ); }
                        S*       SepOp? _
              )+ ARight

Pair          <-
                 i:Identifier S* PairOp S* c:Body                   ~{ ER("expected body after `:`"); }
                                                                     { DK( Pair, i, c ); }
              /
                 k:KeyExpr    S* PairOp S* v:Expr                   ~{ ER("expected value expression"); }
                                                                     { DK( Pair, k, v ); }
KeyExpr       <-
              (
                 k:Variable / k:StrLiteral / k:Integer
              )                                                      { $$ = k; }

JsonBlock     <- Json   S+ s:StrBlock                               ~{ ER("expected string literal block after `json`"); }
                                                                     { DK( JsonBlock, s ); }

StrBlock      <- "\"\"\"" < ( !"\"\"\"" . )* > "\"\"\""              { NS( String ); }
StrLiteral    <- s1:SingleQuote                                      { $$ = s1; }
              /  s2:DblQuote                                         { $$ = s2; }
DblQuote      <- ( "\"" <              [^"]*    > "\"" )             { NS( String ); }
SingleQuote   <- ( "'"  <              [^']*    >  "'" )             { NS( String ); }
Command       <-        <   W ( W / '-'   )*    >                    { NS( String ); }
Identifier    <-        <   A ( W / '-'   )*    >                    { NS( Identifier); }
ArgShort      <-   '-'  <       W+              >                    { NS( ArgShort ); }
ArgLong       <-  "--"  <     ( W ( '-' W )* )+ >                    { NS( ArgLong ); }
String        <-        <       C+              >                    { NS( String ); }
Regex         <-  'r/'  <    ( '\/' / !'/' . )+ > '/'                { NS( Regex ); }
Error         <-        <  'E'        [A-Z]+    >                    { NS( Error ); }
Signal        <-        < "SIG"       [A-Z]+    >                    { NS( Signal ); }

Number        <- d:Decimal                                           { $$ = d; }
               / i:Integer                                           { $$ = i; }
Decimal       <- < [0-9]+ '.' [0-9]+ >                               { NS( Decimal ); }

DateTime      <- d:Date [Tt @] t:Time                                { DK( DateTime, d, t ); }
Date          <- y:Year '-' m:Month  '-' d:Day                       { DK( Date, y, m, d ); }
Time          <- h:Hour ':' m:Minute ':'                             { DK( Time, h, m ); }
              (  s:Second '.' n:NanoSecond                           { NA( $$, s ); NA( $$, n ); }
              /  s:Second                                            { NA( $$, s ); }
              )  z:Timezone?                                         { NA( $$, z ); }
Year          <- <            [0-9] [0-9] [0-9] [0-9]       >        { NS( Year ); }
Month         <- <                        [0-1] [0-9]       >        { NS( Month ); }
Day           <- <                        [0-3] [0-9]       >        { NS( Day ); }
Hour          <- <                        [0-2] [0-9]       >        { NS( Hour ); }
Minute        <- <                        [0-6] [0-9]       >        { NS( Minute ); }
Second        <- <                        [0-6] [0-9]       >        { NS( Second ); }
NanoSecond    <- <                              [0-9]+      >        { NS( NanoSecond ); }
Timezone      <- <  [-+] [0-2] [0-9] ':'? [0-6] [0-9] / 'Z' >        { NS( Timezone ); }

Integer       <-  &"0x"  h:Int16                                     { $$ = h; }
              /   &'0'   o:Int8                                      { $$ = o; }
              /   !'0'   d:Int10                                     { $$ = d; }
Int16         <- < "0x" [0-9A-Fa-f]+ >                               { NS( Int16 ); }
Int8          <- < '0' !'x' [0-7]* >                                 { NS( Int8  ); }
Int10         <- < [0-9]+ >                                          { NS( Int10 ); }

Path          <- < ("."* "/" C+ ) / "." >                            { NS( Path ); }
Variable      <- '$' < W (W / '-')* >                                { NS( Variable ); }
Boolean       <- < "true" / "false" >                                { NS( Boolean ); }
Stream        <- &[ioe] ( s:StreamIn / s:StreamOut / s:StreamErr )   { DK( Stream, s ); }
StreamIn      <- "in"                                                { DK( StreamIn ); }
StreamOut     <- "out"                                               { DK( StreamOut ); }
StreamErr     <- "err"                                               { DK( StreamErr ); }

GeOp          <- ">="                                                { DK( GeOp ); }
GtOp          <- ">"                                                 { DK( GtOp ); }
LeOp          <- "<="                                                { DK( LeOp ); }
LtOp          <- "<"                                                 { DK( LtOp ); }
EqOp          <- "=="                                                { DK( EqOp ); }
NeOp          <- "!="                                                { DK( NeOp ); }
MatchOp       <- "=~"                                                { DK( MatchOp ); }
MulOp         <- "*"                                                 { DK( MulOp ); }
DivOp         <- "/"                                                 { DK( DivOp ); }
ModOp         <- "%"                                                 { DK( ModOp ); }
AddOp         <- "+"                                                 { DK( AddOp ); }
SubOp         <- "-"                                                 { DK( SubOp ); }
SepOp         <- ","
PairOp        <- ":"
PipeOp        <- "|"
VarOp         <- "$"
DerefOp       <- "."
AssignOp      <- "="                                                 { DK( AssignOp ); }
AppendOp      <- "+="                                                { DK( AppendOp ); }
RemoveOp      <- "-="                                                { DK( RemoveOp ); }
DefaultOp     <- "|="                                                { DK( DefaultOp ); }
RedirOper     <-
              (  o:RedirAppendOp / o:RedirReadOp
              /  o:RedirWriteOp / o:RedirDuplexOp
              )                                                      { DK( RedirOper, o ); }
RedirAppendOp <- ">>"                                                { DK( RedirAppendOp ); }
RedirReadOp   <- "<"                                                 { DK( RedirReadOp ); }
RedirWriteOp  <- ">"                                                 { DK( RedirWriteOp ); }
RedirDuplexOp <- "<>"                                                { DK( RedirDuplexOp ); }
CLeft         <- "{"                                                &{ BB('{',  1); }
CRight        <- "}"                                                &{ BB('{', -1); }
ALeft         <- "["                                                &{ BB('[',  1); }
ARight        <- "]"                                                &{ BB('[', -1); }
PLeft         <- "("                                                &{ BB('(',  1); }
PRight        <- ")"                                                &{ BB('(', -1); }
A             <- [A-Za-z]
C             <- [^ \n\r\t;]
S             <- ( "\\" "\n" ) / "\t" / ' '
W             <- [A-Za-z0-9_]
_             <- [ \n\r\t;]*

%%

int packcc_main(const char *input, int len, void *p)
{
	struct deli_t auxil = {
		input: input,
		offset: 0,
		length: len,
		parser: p,
	};
	deli_context_t *ctx = deli_create(&auxil);
	while(deli_parse(ctx, NULL));
	deli_destroy(ctx);
	return 0;
}
