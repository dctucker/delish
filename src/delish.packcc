%prefix "deli"

%auxil "struct deli_t *"

%header {
	#include "delikind.h"
	struct deli_t {
		const char *input;
		size_t offset;
		size_t length;
		void *parser;
	};
}

%source {
	#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
		if( !( dk##rule == dkComment || dk##rule == dkVLine || dk##rule > dkDefaultOp ) ) \
			deli_event(auxil, event, dk##rule, level, pos, buffer, length)
	#define PCC_GETCHAR(auxil) deli_get_character( auxil )
	#define PCC_BUFFERSIZE 1024

	int deli_get_character( struct deli_t *auxil )
	{
		if( auxil->offset >= auxil->length )
			return -1;
		return (auxil)->input[ auxil->offset++ ];
	}
}

Script        <- Code
Code          <- ( Blank* VLine )+ Blank*
Blank         <- ( "\\" "\n" ) / "\t" / ' '
VLine         <- "\n" / Comment / Block / Statement Comment* "\n"
Comment       <- '#' (! "\n" .)* "\n"
Block         <- !'$' (Conditional / WhileLoop / ForLoop / Function) / Subshell
Statement     <- VariableStmt / LocalStmt / ArgStmt / EnvStmt / IncludeStmt / StreamStmt / RunStmt / FunctionStmt
Conditional   <- "if"       Blank+ Expr     Blank+                         "{" _ Code* _ "}" _
WhileLoop     <- "while"    Blank+ Expr     Blank+                         "{" _ Code* _ "}" _
ForLoop       <- "for"      Blank+ Variable Blank+ "in" Blank+ Expr Blank+ "{" _ Code* _ "}" _
Function      <- !Keyword Identifier Blank* "="      Blank*                "{" _ Code* _ "}" _
Subshell      <- "sub"      Blank+          Blank+                         "{" _ Code* _ "}" _
VariableStmt  <- &'$' Variable Blank*
               ( AssignOp Blank* (OpenExpr / ArgExpr / Expr / RunStmt)
               / AppendOp Blank* (ArgExpr / Expr / RunStmt)
               / RemoveOp Blank* (ArgExpr / Expr / RunStmt)
               )
OpenExpr      <- "open" (Blank+ RedirOp)? Blank+ Path
LocalStmt     <- "local" Blank+ Variable ( Blank* "=" Blank* Expr )?
ArgStmt       <- "arg" a:ArgNames (Blank* DefaultOp Blank* d:ArgDefault)?
                 { $$ = createNode2( auxil->parser, dkArgStmt, a, d); }
EnvStmt       <- "env" Blank+ Variable (Blank* DefaultOp Blank* EnvDefault)?
IncludeStmt   <- "include" Blank+ StrLiteral
StreamStmt    <- ( Variable "." )? Stream Blank+ ExprList
RunStmt       <- ( (AsyncFlag / RedirFlag / (AsyncFlag RedirFlag) ) Blank+)? "run" Blank+ Invocation ( Blank* "|" Blank* Invocation )*
FunctionStmt  <- Identifier (Blank+ Expr)*
ArgDefault    <- e:Expr                                         { $$ = createNode1( auxil->parser, dkArgDefault, e ); }
EnvDefault    <- Expr
ExprList      <- Expr ( Blank* ',' Blank* Expr Blank* )*
Invocation    <- Command ( Blank+ !'|' (Expr / String) )*
ArgExpr       <- Arg (Blank+ / '=') Expr?
Expr          <- VarDeref / Arg / Array / Object / StrBlock / StrLiteral / Integer / Boolean / Path / JsonBlock / Stream
VarDeref      <- &'$' Variable ( [.] ( StrLiteral / Integer / Variable / Identifier ) )*
RedirFlag     <- "redir" (Blank+ (Variable / Path / Stream) Blank* RedirOp Blank* (Variable / Path / Stream))+
AsyncFlag     <- "async"
ArgNames      <- ( Blank+ a:Arg )+                              { $$ = createNode1( auxil->parser, dkArgNames, a); }
Arg           <- &'-'
               ( l:ArgLong   { $$ = createNode1( auxil->parser, dkArg, l ); }
               / s:ArgShort  { $$ = createNode1( auxil->parser, dkArg, s ); }
               )
Array         <- '[' ( _ Expr Blank* ','? _ )* ']'
Object        <- '[' ( _ Expr Blank* ':' Blank* Expr Blank* ','? _ )+ ']'
JsonBlock     <- "json" Blank+ StrBlock
Keyword       <- "json" / "sub" / "if" / "while" / "arg" / "in" / "out" / "err" / "include" / "true" / "false" / "env"
StrBlock      <- "\"\"\"" < ( !"\"\"\"" . )* > "\"\"\""         { $$ = parseCapture( auxil->parser, $1s, $1e, $1); }
StrLiteral    <- ( (["] < [^"]* > ["]) / (['] < [^']* > [']) )  { $$ = parseCapture( auxil->parser, $1s, $1e, $1); }
Command       <- < W ( W / '-' )* >                             { $$ = parseCapture( auxil->parser, $1s, $1e, $1); }
Identifier    <- !Keyword < ( W / '-' )+ >                      { $$ = parseCapture( auxil->parser, $1s, $1e, $1); }
ArgShort      <- '-' < W+ >                                     { $$ = createNode( auxil->parser, dkArgShort, $1s, $1e, $1); }
ArgLong       <- "--" < ( W ('-' W )*)+ >                       { $$ = createNode( auxil->parser, dkArgLong , $1s, $1e, $1); }
String        <- < S+ >                                         { $$ = parseCapture( auxil->parser, $1s, $1e, $1); }
Integer       <- < [0-9]+ >                                     { $$ = parseCapture( auxil->parser, $1s, $1e, $1); }
Path          <- < ("."* "/" S+ ) / "." >                       { $$ = parseCapture( auxil->parser, $1s, $1e, $1); }
Variable      <- '$' < (W / '-')+ >                             { $$ = parseCapture( auxil->parser, $1s, $1e, $1); }
Boolean       <- < "true" / "false" >                           { $$ = parseCapture( auxil->parser, $1s, $1e, $1); }
Stream        <- &[ioe] (StreamIn / StreamOut / StreamErr)
StreamIn      <- "in"
StreamOut     <- "out"
StreamErr     <- "err"
AssignOp      <- "="
AppendOp      <- "+="
RemoveOp      <- "-="
RedirOp       <- RedirAppendOp / RedirReadOp / RedirWriteOp / RedirDuplexOp
RedirAppendOp <- ">>"
RedirReadOp   <- "<"
RedirWriteOp  <- ">"
RedirDuplexOp <- "<>"
DefaultOp     <- "|="
S             <- [^ \n\r\t]
W             <- [A-Za-z0-9-]
_             <- [ \n\r\t]*

%%

int packcc_main(const char *input, int len, void *p)
{
	struct deli_t auxil = {
		input: input,
		offset: 0,
		length: len,
		parser: p,
	};
	//printf("%x", p);
	deli_context_t *ctx = deli_create(&auxil);
	while(deli_parse(ctx, NULL));
	deli_destroy(ctx);
	return 0;
}
