%prefix "deli"

%auxil "struct deli_t *"

%header {
	#include "delikind.h"
	struct deli_t {
		const char *input;
		size_t offset;
		size_t length;
		void *parser;
	};
}

%source {
	#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) \
		if( !( dk##rule == dkComment || dk##rule == dkVLine || dk##rule > dkDefaultOp ) ) \
			deli_event(auxil, event, dk##rule, level, pos, buffer, length)
	#define PCC_GETCHAR(auxil) deli_get_character( auxil )
	#define PCC_BUFFERSIZE 1024

	int deli_get_character( struct deli_t *auxil )
	{
		if( auxil->offset >= auxil->length )
			return -1;
		return (auxil)->input[ auxil->offset++ ];
	}
}

Script        <- c:Code                                              { $$ = createNode1( auxil->parser, dkScript, c ); }
Code          <-                                                     { $$ = createNode0( auxil->parser, dkCode ); }
              (  Blank* l:VLine                                      { if( l >= 0 ) nodeAppend( auxil->parser, $$, l ); }
              )+ Blank*
Blank         <- ( "\\" "\n" ) / "\t" / ' '
VLine         <- ( "\n"                                              { $$ = -1; }
                 / Comment                                           { $$ = -1; }
                 / a:Block                                           { $$ = a; }
                 / a:Statement Comment* "\n"                         { $$ = a; }
                 )                                                   { if( $$ >= 0 ) setLine( auxil->parser, $$, $0s ); }
Comment       <- '#' (! "\n" .)* "\n"
Block         <- ( !'$'
              (  a:Conditional / a:WhileLoop / a:ForLoop / a:Function
              )  / a:Subshell )                                      { $$ = createNode1( auxil->parser, dkBlock    , a ); }
Statement     <-
              (  a:VariableStmt /  a:LocalStmt    /  a:ArgStmt
              /  a:EnvStmt      /  a:IncludeStmt  /  a:StreamStmt
              /  a:RunStmt      /  a:FunctionStmt )                  { $$ = createNode1( auxil->parser, dkStatement, a); setLine( auxil->parser, a, $0s ); }
Conditional   <- "if"       Blank+ e:Expr
                 Blank+ "{" _ c:Code? _ "}" _                        { $$ = createNode1( auxil->parser, dkConditional, e, c ); }
WhileLoop     <- "while"    Blank+ e:Expr
                 Blank+ "{" _ c:Code? _ "}" _                        { $$ = createNode1( auxil->parser, dkWhileLoop  , e, c ); }
ForLoop       <- "for"      Blank+ v:Variable Blank+ "in" Blank+ e:Expr
                 Blank+ "{" _ c:Code? _ "}" _                        { $$ = createNode3( auxil->parser, dkForLoop    , v, e, c ); }
Function      <- !Keyword i:Identifier Blank*        "="
                 Blank* "{" _ c:Code? _ "}" _                        { $$ = createNode1( auxil->parser, dkFunction   , i, c ); }
Subshell      <- "sub"      Blank+          Blank+
                 "{" _ c:Code? _ "}" _                               { $$ = createNode1( auxil->parser, dkSubshell   , c ); }
VariableStmt  <- &'$' v:Variable Blank*
              (  o:AssignOp Blank* (e:OpenExpr / e:ArgExpr / e:Expr / e:RunStmt)
              /  o:AppendOp Blank* (e:ArgExpr / e:Expr / e:RunStmt)
              /  o:RemoveOp Blank* (e:ArgExpr / e:Expr / e:RunStmt)
              )                                                      { $$ = createNode3( auxil->parser, dkVariableStmt, v, o, e ); }
OpenExpr      <- "open" (Blank+ o:RedirOp)? Blank+ p:Path            { $$ = createNode2( auxil->parser, dkOpenExpr, p, o); }
LocalStmt     <- "local" Blank+ v:Variable                           { $$ = createNode1( auxil->parser, dkLocalStmt, v ); }
              (  Blank* "=" Blank* e:Expr                            { nodeAppend( auxil->parser, $$, e ); }
              )?
ArgStmt       <- "arg"
                 ( a:ArgNames Blank* o:DefaultOp Blank* d:ArgDefault { $$ = createNode3( auxil->parser, dkArgStmt, a, o, d); }
                 / a:ArgNames                                        { $$ = createNode1( auxil->parser, dkArgStmt, a); }
                 )
EnvStmt       <- "env" Blank+ v:Variable                             { $$ = createNode1( auxil->parser, dkEnvStmt, v ); }
                 (Blank* o:DefaultOp Blank* e:EnvDefault             { nodeAppend( auxil->parser, $$, o ); nodeAppend( auxil->parser, $$, e ); }
                 )?
IncludeStmt   <- "include" Blank+ s:StrLiteral                       { $$ = createNode1( auxil->parser, dkIncludeStmt, s ); }
StreamStmt    <- ( v:Variable "." s:Stream Blank+ l:ExprList         { $$ = createNode3( auxil->parser, dkStreamStmt,  v, s, l ); }
              /                   s:Stream Blank+ l:ExprList         { $$ = createNode2( auxil->parser, dkStreamStmt,  s, l ); }
              )
RunStmt       <- (
              (
                 f1:AsyncFlag / f2:RedirFlag / (f1:AsyncFlag f2:RedirFlag)
              )  Blank+
              )? "run" Blank+ i:Invocation                           { $$ = createNode1( auxil->parser, dkRunStmt, i ); }
              (  Blank* "|" Blank* i:Invocation                      { nodeAppend( auxil->parser, $$, i ); }
              )*
FunctionStmt  <- i:Identifier                                        { $$ = createNode1( auxil->parser, dkFunctionStmt, i ); }
               ( Blank+ e:Expr                                       { nodeAppend( auxil->parser, $$, e ); }
               )*
ArgDefault    <- e:Expr                                              { $$ = createNode1( auxil->parser, dkArgDefault, e ); }
EnvDefault    <- e:Expr                                              { $$ = createNode1( auxil->parser, dkEnvDefault, e ); }
ExprList      <- e:Expr                                              { $$ = createNode1( auxil->parser, dkExprList, e ); }
               ( Blank* ',' Blank* e:Expr Blank*                     { nodeAppend( auxil->parser, $$, e ); }
               )*
Invocation    <- c:Command                                           { $$ = createNode1( auxil->parser, dkInvocation, c ); }
              (  Blank+ !'|' (e:Expr / e:String)                     { nodeAppend( auxil->parser, $$, e ); }
              )*
ArgExpr       <- a:Arg (Blank+ / '=') e:Expr?                        { $$ = createNode2( auxil->parser, dkArgExpr, a, e ); }
Expr          <-
               ( s:VarDeref / s:Arg        / s:Array   / s:Object
               / s:StrBlock / s:StrLiteral / s:Integer / s:Boolean
               / s:Path     / s:JsonBlock  / s:Stream             )  { $$ = createNode1( auxil->parser, dkExpr, s); }
VarDeref      <- &'$' n:Variable                                     { $$ = createNode1( auxil->parser, dkVarDeref, n ); }
              (  [.]
              (  s:StrLiteral / s:Integer / s:Variable / s:Identifier )   { nodeAppend( auxil->parser, $$, s ); }
              )*
RedirFlag     <- "redir" (Blank+ (Variable / Path / Stream) Blank* RedirOp Blank* (Variable / Path / Stream))+
AsyncFlag     <- "async"
ArgNames      <- ( Blank+ a:Arg )+                                   { $$ = createNode1( auxil->parser, dkArgNames, a); }
Arg           <- &'-'
              (  l:ArgLong                                           { $$ = createNode1( auxil->parser, dkArg, l ); }
              /  s:ArgShort                                          { $$ = createNode1( auxil->parser, dkArg, s ); }
              )
Array         <- '['                                                 { $$ = createNode0( auxil->parser, dkArray ); }
              (  _ e:Expr                                            { nodeAppend( auxil->parser, $$, e ); }
                 Blank* ','? _
              )* ']'
Object        <- '['                                                 { $$ = createNode0( auxil->parser, dkObject ); }
              (  _ p:Pair                                            { nodeAppend( auxil->parser, $$, p ); }
                 Blank* ','? _
              )+ ']'
Pair          <- k:Expr Blank* ':' Blank* v:Expr                     { $$ = createNode2( auxil->parser, dkPair, k, v ); }
JsonBlock     <- "json" Blank+ s:StrBlock                            { $$ = createNode1( auxil->parser, dkJsonBlock, s ); }
Keyword       <- "json" / "sub" / "if" / "while" / "arg" / "in"
              /  "out" / "err" / "include" / "true" / "false" / "env"
StrBlock      <- "\"\"\"" < ( !"\"\"\"" . )* > "\"\"\""              { $$ = nodeString( auxil->parser, dkString    , $1s, $1e, $1); }
StrLiteral    <- ( (["] < [^"]* > ["]) / (['] < [^']* > [']) )       { $$ = nodeString( auxil->parser, dkString    , $1s, $1e, $1); }
Command       <- < W ( W / '-' )* >                                  { $$ = nodeString( auxil->parser, dkCommand   , $1s, $1e, $1); }
Identifier    <- !Keyword < ( W / '-' )+ >                           { $$ = nodeString( auxil->parser, dkIdentifier, $1s, $1e, $1); }
ArgShort      <- '-' < W+ >                                          { $$ = nodeString( auxil->parser, dkArgShort  , $1s, $1e, $1); }
ArgLong       <- "--" < ( W ('-' W )*)+ >                            { $$ = nodeString( auxil->parser, dkArgLong   , $1s, $1e, $1); }
String        <- < S+ >                                              { $$ = nodeString( auxil->parser, dkString    , $1s, $1e, $1); }
Integer       <- < [0-9]+ >                                          { $$ = nodeString( auxil->parser, dkInteger   , $1s, $1e, $1); }
Path          <- < ("."* "/" S+ ) / "." >                            { $$ = nodeString( auxil->parser, dkPath      , $1s, $1e, $1); }
Variable      <- '$' < (W / '-')+ >                                  { $$ = nodeString( auxil->parser, dkVariable  , $1s, $1e, $1); }
Boolean       <- < "true" / "false" >                                { $$ = nodeString( auxil->parser, dkBoolean   , $1s, $1e, $1); }
Stream        <- &[ioe] ( s:StreamIn / s:StreamOut / s:StreamErr )   { $$ = s; }
StreamIn      <- "in"                                                { $$ = createNode0( auxil->parser, dkStreamIn ); }
StreamOut     <- "out"                                               { $$ = createNode0( auxil->parser, dkStreamOut ); }
StreamErr     <- "err"                                               { $$ = createNode0( auxil->parser, dkStreamErr ); }
AssignOp      <- "="                                                 { $$ = createNode0( auxil->parser, dkAssignOp ); }
AppendOp      <- "+="                                                { $$ = createNode0( auxil->parser, dkAppendOp ); }
RemoveOp      <- "-="                                                { $$ = createNode0( auxil->parser, dkRemoveOp ); }
RedirOp       <- ( o:RedirAppendOp / o:RedirReadOp
               / o:RedirWriteOp / o:RedirDuplexOp )                  { $$ = o; }
RedirAppendOp <- ">>"                                                { $$ = createNode0( auxil->parser, dkRedirAppendOp ); }
RedirReadOp   <- "<"                                                 { $$ = createNode0( auxil->parser, dkRedirReadOp ); }
RedirWriteOp  <- ">"                                                 { $$ = createNode0( auxil->parser, dkRedirWriteOp ); }
RedirDuplexOp <- "<>"                                                { $$ = createNode0( auxil->parser, dkRedirDuplexOp ); }
DefaultOp     <- "|="                                                { $$ = createNode0( auxil->parser, dkDefaultOp ); }
S             <- [^ \n\r\t]
W             <- [A-Za-z0-9-]
_             <- [ \n\r\t]*

%%

int packcc_main(const char *input, int len, void *p)
{
	struct deli_t auxil = {
		input: input,
		offset: 0,
		length: len,
		parser: p,
	};
	//printf("%x", p);
	deli_context_t *ctx = deli_create(&auxil);
	while(deli_parse(ctx, NULL));
	deli_destroy(ctx);
	return 0;
}
